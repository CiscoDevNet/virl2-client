#
# Python bindings for the Cisco VIRL 2 Network Simulation Platform
#
# This file is part of VIRL 2
#
# Copyright 2020 Cisco Systems Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import pytest

from virl2_client import ClientLibrary


TEST_TOPOLOGIES = ["mixed-0.0.1.yaml", "mixed-0.0.4.yaml", "mixed-0.0.5.yaml"]


@pytest.fixture
def cleanup_test_labs(client_library_session: ClientLibrary):
    """Remove all labs after the test."""
    yield
    lab_list = client_library_session.get_lab_list()
    for lab_id in lab_list:
        lab = client_library_session.join_existing_lab(lab_id)
        lab.stop()
        lab.wipe()
        client_library_session.remove_lab(lab_id)


@pytest.mark.integration
@pytest.mark.nomock
@pytest.mark.parametrize(argnames="topology", argvalues=TEST_TOPOLOGIES)
def test_import_export_yaml(
    client_library_session: ClientLibrary,
    topology,
    change_test_dir,
    cleanup_test_labs,
    tmpdir,
):
    """Use the API to import a topology from YAML file, export it,
    then import it back and compare with the initial import.
    """

    # Import lab from test data YAML file
    reimported_lab_title = "export_import_test.yaml"
    topology_file_path = f"test_data/{topology}"
    imported_lab = client_library_session.import_lab_from_path(topology_file_path)

    # Export the lab we just imported, save to YAML file
    exported_lab = imported_lab.download()
    exported_file_path = tmpdir.mkdir("yaml").join(reimported_lab_title)
    exported_file_path.write(exported_lab)

    # Import the lab from the exported YAML file
    reimported_lab = client_library_session.import_lab_from_path(exported_file_path)

    # Get the topology data for each lab
    url = (
        client_library_session._context.base_url
        + f"labs/{imported_lab._lab_id}/topology"
    )
    response = client_library_session._context.session.get(url)
    response.raise_for_status()
    lab_data = response.json()

    url = (
        client_library_session._context.base_url
        + f"labs/{reimported_lab._lab_id}/topology"
    )
    response = client_library_session._context.session.get(url)
    response.raise_for_status()
    reimported_lab_data = response.json()

    # Compare the initial import with the reimport
    for item in ["lab_description", "lab_owner"]:
        assert lab_data[item] == reimported_lab_data[item]

    lab_notes = lab_data["lab_notes"]
    if not lab_notes:
        # If the lab had no notes, the reimport should be empty as well.
        assert lab_notes == reimported_lab_data["lab_notes"]
    else:
        # Import warnings are appended to lab notes, if there are any the re-import should have them twice
        # We don't know if they're import warnings or actual notes, so do nothing
        pass

    # Compare individual topology items
    for item in ["nodes", "interfaces", "links"]:
        # item order should be preserved
        for original_item, reimported_item in zip(
            lab_data[item], reimported_lab_data[item]
        ):
            original_data = original_item["data"]
            reimported_data = reimported_item["data"]
            for key in original_data.keys():
                # Do not compare any IDs, they are autogenerated on import
                if (
                    key
                    in [
                        "id",
                        "lab_id",
                        "node",
                        "node_a",
                        "node_b",
                        "interface_a",
                        "interface_b",
                    ]
                    or "uuid" in key
                ):
                    continue
                else:
                    assert original_data[key] == reimported_data[key]
